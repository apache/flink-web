<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Apache Flink: Off-heap Memory in Apache Flink and the curious JIT compiler</title>
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <!-- Bootstrap -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/flink.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Blog RSS feed -->
    <link href="/blog/feed.xml" rel="alternate" type="application/rss+xml" title="Apache Flink Blog: RSS feed" />

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <!-- We need to load Jquery in the header for custom google analytics event tracking-->
    <script src="/js/jquery.min.js"></script>

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Matomo -->
    <script>
      var _paq = window._paq = window._paq || [];
      /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
      /* We explicitly disable cookie tracking to avoid privacy issues */
      _paq.push(['disableCookies']);
      /* Measure a visit to flink.apache.org and nightlies.apache.org/flink as the same visit */
      _paq.push(["setDomains", ["*.flink.apache.org","*.nightlies.apache.org/flink"]]);
      _paq.push(['trackPageView']);
      _paq.push(['enableLinkTracking']);
      (function() {
        var u="//matomo.privacy.apache.org/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '1']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
      })();
    </script>
    <!-- End Matomo Code -->
  </head>
  <body>  
    

    <!-- Main content. -->
    <div class="container">
    <div class="row">

      
     <div id="sidebar" class="col-sm-3">
        

<!-- Top navbar. -->
    <nav class="navbar navbar-default">
        <!-- The logo. -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <div class="navbar-logo">
            <a href="/">
              <img alt="Apache Flink" src="/img/flink-header-logo.svg" width="147px" height="73px">
            </a>
          </div>
        </div><!-- /.navbar-header -->

        <!-- The navigation links. -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
          <ul class="nav navbar-nav navbar-main">

            <!-- First menu section explains visitors what Flink is -->

            <!-- What is Stream Processing? -->
            <!--
            <li><a href="/streamprocessing1.html">What is Stream Processing?</a></li>
            -->

            <!-- What is Flink? -->
            <li><a href="/flink-architecture.html">What is Apache Flink?</a></li>

            

            <!-- Stateful Functions? -->

            <li><a href="https://nightlies.apache.org/flink/flink-statefun-docs-stable/">What is Stateful Functions?</a></li>

            <!-- Flink ML? -->

            <li><a href="https://nightlies.apache.org/flink/flink-ml-docs-stable/">What is Flink ML?</a></li>

            <!-- Flink Kubernetes Operator? -->

            <li><a href="https://nightlies.apache.org/flink/flink-kubernetes-operator-docs-stable/">What is the Flink Kubernetes Operator?</a></li>

            <!-- Flink Table Store? -->

            <li><a href="https://nightlies.apache.org/flink/flink-table-store-docs-stable/">What is Flink Table Store?</a></li>

            <!-- Use cases -->
            <li><a href="/usecases.html">Use Cases</a></li>

            <!-- Powered by -->
            <li><a href="/poweredby.html">Powered By</a></li>


            &nbsp;
            <!-- Second menu section aims to support Flink users -->

            <!-- Downloads -->
            <li><a href="/downloads.html">Downloads</a></li>

            <!-- Getting Started -->
            <li class="dropdown">
              <a class="dropdown-toggle" data-toggle="dropdown" href="#">Getting Started<span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="https://nightlies.apache.org/flink/flink-docs-release-1.15//docs/try-flink/local_installation/" target="_blank">With Flink <small><span class="glyphicon glyphicon-new-window"></span></small></a></li>
                <li><a href="https://nightlies.apache.org/flink/flink-statefun-docs-release-3.2/getting-started/project-setup.html" target="_blank">With Flink Stateful Functions <small><span class="glyphicon glyphicon-new-window"></span></small></a></li>
                <li><a href="https://nightlies.apache.org/flink/flink-ml-docs-release-2.1/try-flink-ml/quick-start.html" target="_blank">With Flink ML <small><span class="glyphicon glyphicon-new-window"></span></small></a></li>
                <li><a href="https://nightlies.apache.org/flink/flink-kubernetes-operator-docs-release-1.2/try-flink-kubernetes-operator/quick-start.html" target="_blank">With Flink Kubernetes Operator <small><span class="glyphicon glyphicon-new-window"></span></small></a></li>
                <li><a href="https://nightlies.apache.org/flink/flink-table-store-docs-release-0.2/try-table-store/quick-start.html" target="_blank">With Flink Table Store <small><span class="glyphicon glyphicon-new-window"></span></small></a></li>
                <li><a href="/training.html">Training Course</a></li>
              </ul>
            </li>

            <!-- Documentation -->
            <li class="dropdown">
              <a class="dropdown-toggle" data-toggle="dropdown" href="#">Documentation<span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="https://nightlies.apache.org/flink/flink-docs-release-1.15" target="_blank">Flink 1.15 (Latest stable release) <small><span class="glyphicon glyphicon-new-window"></span></small></a></li>
                <li><a href="https://nightlies.apache.org/flink/flink-docs-master" target="_blank">Flink Master (Latest Snapshot) <small><span class="glyphicon glyphicon-new-window"></span></small></a></li>
                <li><a href="https://nightlies.apache.org/flink/flink-statefun-docs-release-3.2" target="_blank">Flink Stateful Functions 3.2 (Latest stable release) <small><span class="glyphicon glyphicon-new-window"></span></small></a></li>
                <li><a href="https://nightlies.apache.org/flink/flink-statefun-docs-master" target="_blank">Flink Stateful Functions Master (Latest Snapshot) <small><span class="glyphicon glyphicon-new-window"></span></small></a></li>
                <li><a href="https://nightlies.apache.org/flink/flink-ml-docs-release-2.1" target="_blank">Flink ML 2.1 (Latest stable release) <small><span class="glyphicon glyphicon-new-window"></span></small></a></li>
                <li><a href="https://nightlies.apache.org/flink/flink-ml-docs-master" target="_blank">Flink ML Master (Latest Snapshot) <small><span class="glyphicon glyphicon-new-window"></span></small></a></li>
                <li><a href="https://nightlies.apache.org/flink/flink-kubernetes-operator-docs-release-1.2" target="_blank">Flink Kubernetes Operator 1.2 (Latest stable release) <small><span class="glyphicon glyphicon-new-window"></span></small></a></li>
                <li><a href="https://nightlies.apache.org/flink/flink-kubernetes-operator-docs-main" target="_blank">Flink Kubernetes Operator Main (Latest Snapshot) <small><span class="glyphicon glyphicon-new-window"></span></small></a></li>
                <li><a href="https://nightlies.apache.org/flink/flink-table-store-docs-release-0.2" target="_blank">Flink Table Store 0.2 (Latest stable release) <small><span class="glyphicon glyphicon-new-window"></span></small></a></li>
                <li><a href="https://nightlies.apache.org/flink/flink-table-store-docs-master" target="_blank">Flink Table Store Master (Latest Snapshot) <small><span class="glyphicon glyphicon-new-window"></span></small></a></li>
              </ul>
            </li>

            <!-- getting help -->
            <li><a href="/gettinghelp.html">Getting Help</a></li>

            <!-- Blog -->
            <li class="active"><a href="/blog/"><b>Flink Blog</b></a></li>


            <!-- Flink-packages -->
            <li>
              <a href="https://flink-packages.org" target="_blank">flink-packages.org <small><span class="glyphicon glyphicon-new-window"></span></small></a>
            </li>
            &nbsp;

            <!-- Third menu section aim to support community and contributors -->

            <!-- Community -->
            <li><a href="/community.html">Community &amp; Project Info</a></li>

            <!-- Roadmap -->
            <li><a href="/roadmap.html">Roadmap</a></li>

            <!-- Contribute -->
            <li><a href="/contributing/how-to-contribute.html">How to Contribute</a></li>
            

            <!-- GitHub -->
            <li>
              <a href="https://github.com/apache/flink" target="_blank">Flink on GitHub <small><span class="glyphicon glyphicon-new-window"></span></small></a>
            </li>

            &nbsp;

            <!-- Language Switcher -->
            <li>
              
                
                  <!-- link to the Chinese home page when current is blog page -->
                  <a href="/zh">中文版</a>
                
              
            </li>

          </ul>

          <style>
            .smalllinks:link {
              display: inline-block !important; background: none; padding-top: 0px; padding-bottom: 0px; padding-right: 0px; min-width: 75px;
            }
          </style>

          <ul class="nav navbar-nav navbar-bottom">
          <hr />

            <!-- Twitter -->
            <li><a href="https://twitter.com/apacheflink" target="_blank">@ApacheFlink <small><span class="glyphicon glyphicon-new-window"></span></small></a></li>

            <!-- Visualizer -->
            <li class=" hidden-md hidden-sm"><a href="/visualizer/" target="_blank">Plan Visualizer <small><span class="glyphicon glyphicon-new-window"></span></small></a></li>

            <li >
                  <a href="/security.html">Flink Security</a>
            </li>

          <hr />

            <li><a href="https://apache.org" target="_blank">Apache Software Foundation <small><span class="glyphicon glyphicon-new-window"></span></small></a></li>

            <li>

              <a class="smalllinks" href="https://www.apache.org/licenses/" target="_blank">License</a> <small><span class="glyphicon glyphicon-new-window"></span></small>

              <a class="smalllinks" href="https://www.apache.org/security/" target="_blank">Security</a> <small><span class="glyphicon glyphicon-new-window"></span></small>

              <a class="smalllinks" href="https://www.apache.org/foundation/sponsorship.html" target="_blank">Donate</a> <small><span class="glyphicon glyphicon-new-window"></span></small>

              <a class="smalllinks" href="https://www.apache.org/foundation/thanks.html" target="_blank">Thanks</a> <small><span class="glyphicon glyphicon-new-window"></span></small>
            </li>

          </ul>
        </div><!-- /.navbar-collapse -->
    </nav>

      </div>
      <div class="col-sm-9">
      <div class="row-fluid">
  <div class="col-sm-12">
    <div class="row">
      <h1>Off-heap Memory in Apache Flink and the curious JIT compiler</h1>
      <p><i></i></p>

      <article>
        <p>16 Sep 2015 by Stephan Ewen (<a href="https://twitter.com/stephanewen">@stephanewen</a>)</p>

<p>Running data-intensive code in the JVM and making it well-behaved is tricky. Systems that put billions of data objects naively onto the JVM heap face unpredictable OutOfMemoryErrors and Garbage Collection stalls. Of course, you still want to to keep your data in memory as much as possible, for speed and responsiveness of the processing applications. In that context, “off-heap” has become almost something like a magic word to solve these problems.</p>

<p>In this blog post, we will look at how Flink exploits off-heap memory. The feature is part of the upcoming release, but you can try it out with the latest nightly builds. We will also give a few interesting insights into the behavior for Java’s JIT compiler for highly optimized methods and loops.</p>

<h2 id="recap-memory-management-in-flink">Recap: Memory Management in Flink</h2>

<p>To understand Flink’s approach to off-heap memory, we need to recap Flink’s approach to custom managed memory. We have written an <a href="/news/2015/05/11/Juggling-with-Bits-and-Bytes.html">earlier blog post about how Flink manages JVM memory itself</a></p>

<p>As a summary, the core part is that Flink implements its algorithms not against Java objects, arrays, or lists, but actually against a data structure similar to <code>java.nio.ByteBuffer</code>. Flink uses its own specialized version, called <a href="https://github.com/apache/flink/blob/release-0.9.1-rc1/flink-core/src/main/java/org/apache/flink/core/memory/MemorySegment.java"><code>MemorySegment</code></a> on which algorithms put and get at specific positions ints, longs, byte arrays, etc, and compare and copy memory. The memory segments are held and distributed by a central component (called <code>MemoryManager</code>) from which algorithms request segments according to their calculated memory budgets.</p>

<p>Don’t believe that this can be fast? Have a look at the <a href="/news/2015/05/11/Juggling-with-Bits-and-Bytes.html">benchmarks in the earlier blogpost</a>, which show that it is actually often much faster than working on objects, due to better control over data layout (cache efficiency, data size), and reducing the pressure on Java’s Garbage Collector.</p>

<p>This form of memory management has been in Flink for a long time. Anecdotally, the first public demo of Flink’s predecessor project <em>Stratosphere</em>, at the VLDB conference in 2010, was running its programs with custom managed memory (although I believe few attendees were aware of that).</p>

<h2 id="why-actually-bother-with-off-heap-memory">Why actually bother with off-heap memory?</h2>

<p>Given that Flink has a sophisticated level of managing on-heap memory, why do we even bother with off-heap memory? It is true that <em>“out of memory”</em> has been much less of a problem for Flink because of its heap memory management techniques. Nonetheless, there are a few good reasons to offer the possibility to move Flink’s managed memory out of the JVM heap:</p>

<ul>
  <li>
    <p>Very large JVMs (100s of GBytes heap memory) tend to be tricky. It takes long to start them (allocate and initialize heap) and garbage collection stalls can be huge (minutes). While newer incremental garbage collectors (like G1) mitigate this problem to some extend, an even better solution is to just make the heap much smaller and allocate Flink’s managed memory chunks outside the heap.</p>
  </li>
  <li>
    <p>I/O and network efficiency: In many cases, we write MemorySegments to disk (spilling) or to the network (data transfer). Off-heap memory can be written/transferred with zero copies, while heap memory always incurs an additional memory copy.</p>
  </li>
  <li>
    <p>Off-heap memory can actually be owned by other processes. That way, cached data survives process crashes (due to user code exceptions) and can be used for recovery. Flink does not exploit that, yet, but it is interesting future work.</p>
  </li>
</ul>

<p>The opposite question is also valid. Why should Flink ever not use off-heap memory?</p>

<ul>
  <li>
    <p>On-heap is easier and interplays better with tools. Some container environments and monitoring tools get confused when the monitored heap size does not remotely reflect the amount of memory used by the process.</p>
  </li>
  <li>
    <p>Short lived memory segments are cheaper on the heap. Flink sometimes needs to allocate some short lived buffers, which works cheaper on the heap than off-heap.</p>
  </li>
  <li>
    <p>Some operations are actually a bit faster on heap memory (or the JIT compiler understands them better).</p>
  </li>
</ul>

<h2 id="the-off-heap-memory-implementation">The off-heap Memory Implementation</h2>

<p>Given that all memory intensive internal algorithms are already implemented against the <code>MemorySegment</code>, our implementation to switch to off-heap memory is actually trivial. You can compare it to replacing all <code>ByteBuffer.allocate(numBytes)</code> calls with <code>ByteBuffer.allocateDirect(numBytes)</code>. In Flink’s case it meant that we made the <code>MemorySegment</code> abstract and added the <code>HeapMemorySegment</code> and <code>OffHeapMemorySegment</code> subclasses. The <code>OffHeapMemorySegment</code> takes the off-heap memory pointer from a <code>java.nio.DirectByteBuffer</code> and implements its specialized access methods using <code>sun.misc.Unsafe</code>. We also made a few adjustments to the startup scripts and the deployment code to make sure that the JVM is permitted enough off-heap memory (direct memory, <em>-XX:MaxDirectMemorySize</em>).</p>

<p>In practice we had to go one step further, to make the implementation perform well. While the <code>ByteBuffer</code> is used in I/O code paths to compose headers and move bulk memory into place, the MemorySegment is part of the innermost loops of many algorithms (sorting, hash tables, …). That means that the access methods have to be as fast as possible.</p>

<h2 id="understanding-the-jit-and-tuning-the-implementation">Understanding the JIT and tuning the implementation</h2>

<p>The <code>MemorySegment</code> was (before our change) a standalone class, it was <em>final</em> (had no subclasses). Via <em>Class Hierarchy Analysis (CHA)</em>, the JIT compiler was able to determine that all of the accessor method calls go to one specific implementation. That way, all method calls can be perfectly de-virtualized and inlined, which is essential to performance, and the basis for all further optimizations (like vectorization of the calling loop).</p>

<p>With two different memory segments loaded at the same time, the JIT compiler cannot perform the same level of optimization any more, which results in a noticeable difference in performance: A slowdown of about 2.7 x in the following example:</p>

<div class="highlight"><pre><code>Writing 100000 x 32768 bytes to 32768 bytes segment:

HeapMemorySegment    (standalone) : 1,441 msecs
OffHeapMemorySegment (standalone) : 1,628 msecs
HeapMemorySegment    (subclass)   : 3,841 msecs
OffHeapMemorySegment (subclass)   : 3,847 msecs
</code></pre></div>

<p>To get back to the original performance, we explored two approaches:</p>

<h3 id="approach-1-make-sure-that-only-one-memory-segment-implementation-is-ever-loaded">Approach 1: Make sure that only one memory segment implementation is ever loaded.</h3>

<p>We re-structured the code a bit to make sure that all places that produce long-lived and short-lived memory segments instantiate the same MemorySegment subclass (Heap- or Off-Heap segment). Using factories rather than directly instantiating the memory segment classes, this was straightforward.</p>

<p>Experiments (see appendix) showed that the JIT compiler properly detects this (via hierarchy analysis) and that it can perform the same level of aggressive optimization as before, when there was only one <code>MemorySegment</code> class.</p>

<h3 id="approach-2-write-one-segment-that-handles-both-heap-and-off-heap-memory">Approach 2: Write one segment that handles both heap and off-heap memory</h3>

<p>We created a class <code>HybridMemorySegment</code> which handles transparently both heap- and off-heap memory. It can be initialized either with a byte array (heap memory), or with a pointer to a memory region outside the heap (off-heap memory).</p>

<p>Fortunately, there is a nice trick to do this without introducing code branches and specialized handling of the two different memory types. The trick is based on the way that the <code>sun.misc.Unsafe</code> methods interpret object references. To illustrate this, we take the method that gets a long integer from a memory position:</p>

<div class="highlight"><pre><code>sun.misc.Unsafe.getLong(Object reference, long offset)
</code></pre></div>

<p>The method accepts an object reference, takes its memory address, and add the offset to obtain a pointer. It then fetches the eight bytes at the address pointed to and interprets them as a long integer. Since the method accepts <em>null</em> as the reference (and interprets it a <em>zero</em>) one can write a method that fetches a long integer seamlessly from heap and off-heap memory as follows:</p>

<div class="highlight"><pre><code class="language-java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HybridMemorySegment</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">heapMemory</span><span class="o">;</span>  <span class="c1">// non-null in heap case, null in off-heap case</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">address</span><span class="o">;</span>       <span class="c1">// may be absolute, or relative to byte[]</span>


  <span class="c1">// method of interest</span>
  <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getLong</span><span class="o">(</span><span class="kt">int</span> <span class="n">pos</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="n">heapMemory</span><span class="o">,</span> <span class="n">address</span> <span class="o">+</span> <span class="n">pos</span><span class="o">);</span>
  <span class="o">}</span>


  <span class="c1">// initialize for heap memory</span>
  <span class="kd">public</span> <span class="nf">HybridMemorySegment</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">heapMemory</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">heapMemory</span> <span class="o">=</span> <span class="n">heapMemory</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">address</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">arrayBaseOffset</span><span class="o">(</span><span class="kt">byte</span><span class="o">[].</span><span class="na">class</span><span class="o">)</span>
  <span class="o">}</span>
  
  <span class="c1">// initialize for off-heap memory</span>
  <span class="kd">public</span> <span class="nf">HybridMemorySegment</span><span class="o">(</span><span class="kt">long</span> <span class="n">offheapPointer</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">heapMemory</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">address</span> <span class="o">=</span> <span class="n">offheapPointer</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>

<p>To check whether both cases (heap and off-heap) really result in the same code paths (no hidden branches inside the <code>Unsafe.getLong(Object, long)</code> method) one can check out the C++ source code of <code>sun.misc.Unsafe</code>, available here: <a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/prims/unsafe.cpp">http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/prims/unsafe.cpp</a></p>

<p>Of particular interest is the macro in line 155, which is the base of all GET methods. Tracing the function calls (many are no-ops), one can see that both variants of Unsafe’s <code>getLong()</code> result in the same code:
Either <code>0 + absolutePointer</code> or <code>objectRefAddress + offset</code>.</p>

<h2 id="summary">Summary</h2>

<p>We ended up choosing a combination of both techniques:</p>

<ul>
  <li>
    <p>For off-heap memory, we use the <code>HybridMemorySegment</code> from approach (2) which can represent both heap and off-heap memory. That way, the same class represents the long-lived off-heap memory as the short-lived temporary buffers allocated (or wrapped) on the heap.</p>
  </li>
  <li>
    <p>We follow approach (1) to use factories to make sure that one segment is ever only loaded, which gives peak performance. We can exploit the performance benefits of the <code>HeapMemorySegment</code> on individual byte operations, and we have a mechanism in place to add further implementations of <code>MemorySegments</code> for the case that Oracle really removes <code>sun.misc.Unsafe</code> in future Java versions.</p>
  </li>
</ul>

<p>The final code can be found in the Flink repository, under <a href="https://github.com/apache/flink/tree/master/flink-core/src/main/java/org/apache/flink/core/memory">https://github.com/apache/flink/tree/master/flink-core/src/main/java/org/apache/flink/core/memory</a></p>

<p>Detailed micro benchmarks are in the appendix.  A summary of the findings is as follows:</p>

<ul>
  <li>
    <p>The <code>HybridMemorySegment</code> performs equally well in heap and off-heap memory, as is to be expected (the code paths are the same)</p>
  </li>
  <li>
    <p>The <code>HeapMemorySegment</code> is quite a bit faster in reading individual bytes, not so much at writing them. Access to a <em>byte[]</em> is after all a bit cheaper than an invocation of a <code>sun.misc.Unsafe</code> method, even when JIT-ed.</p>
  </li>
  <li>
    <p>The abstract class <code>MemorySegment</code> (with its subclasses <code>HeapMemorySegment</code> and <code>HybridMemorySegment</code>) performs as well as any specialized non-abstract class, as long as only one subclass is loaded. When both are loaded, performance may suffer by a factor of 2.7 x on certain operations.</p>
  </li>
  <li>
    <p>How badly the performance degrades in cases where both MemorySegment subclasses are loaded seems to depend a lot on which subclass is loaded and operated on before and after which. Sometimes, performance is affected more than other times. It seems to be an artifact of the JIT’s code profiling and how heavily it performs optimistic specialization towards certain subclasses.</p>
  </li>
</ul>

<p>There is still a bit of mystery left, specifically why sometimes code is faster when it performs more checks (has more instructions and an additional branch). Even though the branch is perfectly predictable, this seems counter-intuitive. The only explanation that we could come up with is that the branch optimizations (such as optimistic elimination etc) result in code that does better register allocation (for whatever reason, maybe the intermediate instructions just fit the allocation algorithm better).</p>

<h2 id="tldr">tl;dr</h2>

<ul>
  <li>
    <p>Off-heap memory in Flink complements the already very fast on-heap memory management. It improves the scalability to very large heap sizes and reduces memory copies for network and disk I/O.</p>
  </li>
  <li>
    <p>Flink’s already present memory management infrastructure made the addition of off-heap memory simple. Off-heap memory is not only used for caching data, Flink can actually sort data off-heap and build hash tables off-heap.</p>
  </li>
  <li>
    <p>We play a few nice tricks in the implementation to make sure the code is as friendly as possible to the JIT compiler and processor, to make the managed memory accesses are as fast as possible.</p>
  </li>
  <li>
    <p>Understanding the JVM’s JIT compiler is tough - one needs a lot of (randomized) micro benchmarking to examine its behavior.</p>
  </li>
</ul>

<hr />

<h2 id="appendix-detailed-micro-benchmarks">Appendix: Detailed Micro Benchmarks</h2>

<p>These microbenchmarks test the performance of the different memory segment implementations on various operation.</p>

<p>Each experiments tests the different implementations multiple times in different orders, to balance the advantage/disadvantage of the JIT compiler specializing towards certain code paths. All experiments were run 5x, discarding the fastest and slowest run, and then averaged. This compensated for delay before the JIT kicks in.</p>

<p>My setup:</p>

<ul>
  <li>Oracle Java 8 (1.8.0_25)</li>
  <li>4 GBytes JVM heap (the experiments need 1.4 GBytes Heap + 1 GBytes direct memory)</li>
  <li>Intel Core i7-4700MQ CPU, 2.40GHz (4 cores, 8 hardware contexts)</li>
</ul>

<p>The tested implementations are</p>

<table class="table">
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>HeapMemorySegment</code> <em>(exclusive)</em></td>
      <td>The case where it is the only loaded MemorySegment subclass.</td>
    </tr>
    <tr>
      <td><code>HeapMemorySegment</code> <em>(mixed)</em></td>
      <td>The case where both the HeapMemorySegment and the HybridMemorySegment are loaded.</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code> <em>(heap-exclusive)</em></td>
      <td>Backed by heap memory, and the case where it is the only loaded MemorySegment class.</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code> <em>(heap-mixed)</em></td>
      <td>Backed by heap memory, and the case where both the HeapMemorySegment and the HybridMemorySegment are loaded.</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code> <em>(off-heap-exclusive)</em></td>
      <td>Backed by off-heap memory, and the case where it is the only loaded MemorySegment class.</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code> <em>(off-heap-mixed)</em></td>
      <td>Backed by heap off-memory, and the case where both the HeapMemorySegment and the HybridMemorySegment are loaded.</td>
    </tr>
    <tr>
      <td><code>PureHeapSegment</code></td>
      <td>Has no class hierarchy and virtual methods at all.</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code> <em>(heap)</em></td>
      <td>Has no class hierarchy and virtual methods at all, backed by heap memory.</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code> <em>(off-heap)</em></td>
      <td>Has no class hierarchy and virtual methods at all, backed by off-heap memory.</td>
    </tr>
  </tbody>
</table>

<div class="small">
<h3 id="byte-accesses">Byte accesses</h3>

<p><strong>Writing 100000 x 32768 bytes to 32768 bytes segment</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Segment</th>
      <th>Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>HeapMemorySegment</code>, exclusive</td>
      <td>1,441 msecs</td>
    </tr>
    <tr>
      <td><code>HeapMemorySegment</code>, mixed</td>
      <td>3,841 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, heap, exclusive</td>
      <td>1,626 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, off-heap, exclusive</td>
      <td>1,628 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, heap, mixed</td>
      <td>3,848 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, off-heap, mixed</td>
      <td>3,847 msecs</td>
    </tr>
    <tr>
      <td><code>PureHeapSegment</code></td>
      <td>1,442 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, heap</td>
      <td>1,623 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, off-heap</td>
      <td>1,620 msecs</td>
    </tr>
  </tbody>
</table>

<p><strong>Reading 100000 x 32768 bytes from 32768 bytes segment</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Segment</th>
      <th>Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>HeapMemorySegment</code>, exclusive</td>
      <td>1,326 msecs</td>
    </tr>
    <tr>
      <td><code>HeapMemorySegment</code>, mixed</td>
      <td>1,378 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, heap, exclusive</td>
      <td>2,029 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, off-heap, exclusive</td>
      <td>2,030 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, heap, mixed</td>
      <td>2,047 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, off-heap, mixed</td>
      <td>2,049 msecs</td>
    </tr>
    <tr>
      <td><code>PureHeapSegment</code></td>
      <td>1,331 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, heap</td>
      <td>2,030 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, off-heap</td>
      <td>2,030 msecs</td>
    </tr>
  </tbody>
</table>

<p><strong>Writing 10 x 1073741824 bytes to 1073741824 bytes segment</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Segment</th>
      <th>Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>HeapMemorySegment</code>, exclusive</td>
      <td>5,602 msecs</td>
    </tr>
    <tr>
      <td><code>HeapMemorySegment</code>, mixed</td>
      <td>12,570 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, heap, exclusive</td>
      <td>5,691 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, off-heap, exclusive</td>
      <td>5,691 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, heap, mixed</td>
      <td>12,566 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, off-heap, mixed</td>
      <td>12,556 msecs</td>
    </tr>
    <tr>
      <td><code>PureHeapSegment</code></td>
      <td>5,599 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, heap</td>
      <td>5,687 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, off-heap</td>
      <td>5,681 msecs</td>
    </tr>
  </tbody>
</table>

<p><strong>Reading 10 x 1073741824 bytes from 1073741824 bytes segment</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Segment</th>
      <th>Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>HeapMemorySegment</code>, exclusive</td>
      <td>4,243 msecs</td>
    </tr>
    <tr>
      <td><code>HeapMemorySegment</code>, mixed</td>
      <td>4,265 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, heap, exclusive</td>
      <td>6,730 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, off-heap, exclusive</td>
      <td>6,725 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, heap, mixed</td>
      <td>6,933 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, off-heap, mixed</td>
      <td>6,926 msecs</td>
    </tr>
    <tr>
      <td><code>PureHeapSegment</code></td>
      <td>4,247 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, heap</td>
      <td>6,919 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, off-heap</td>
      <td>6,916 msecs</td>
    </tr>
  </tbody>
</table>

<h3 id="byte-array-accesses">Byte Array accesses</h3>

<p><strong>Writing 100000 x 32 byte[1024] to 32768 bytes segment</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Segment</th>
      <th>Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>HeapMemorySegment</code>, mixed</td>
      <td>164 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, heap, mixed</td>
      <td>163 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, off-heap, mixed</td>
      <td>163 msecs</td>
    </tr>
    <tr>
      <td><code>PureHeapSegment</code></td>
      <td>165 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, heap</td>
      <td>182 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, off-heap</td>
      <td>176 msecs</td>
    </tr>
  </tbody>
</table>

<p><strong>Reading 100000 x 32 byte[1024] from 32768 bytes segment</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Segment</th>
      <th>Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>HeapMemorySegment</code>, mixed</td>
      <td>157 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, heap, mixed</td>
      <td>155 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, off-heap, mixed</td>
      <td>162 msecs</td>
    </tr>
    <tr>
      <td><code>PureHeapSegment</code></td>
      <td>161 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, heap</td>
      <td>175 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, off-heap</td>
      <td>179 msecs</td>
    </tr>
  </tbody>
</table>

<p><strong>Writing 10 x 1048576 byte[1024] to 1073741824 bytes segment</strong> </p>

<table class="table">
  <thead>
    <tr>
      <th>Segment</th>
      <th>Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>HeapMemorySegment</code>, mixed</td>
      <td>1,164 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, heap, mixed</td>
      <td>1,173 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, off-heap, mixed</td>
      <td>1,157 msecs</td>
    </tr>
    <tr>
      <td><code>PureHeapSegment</code></td>
      <td>1,169 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, heap</td>
      <td>1,174 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, off-heap</td>
      <td>1,166 msecs</td>
    </tr>
  </tbody>
</table>

<p><strong>Reading 10 x 1048576 byte[1024] from 1073741824 bytes segment</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Segment</th>
      <th>Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>HeapMemorySegment</code>, mixed</td>
      <td>854 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, heap, mixed</td>
      <td>853 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, off-heap, mixed</td>
      <td>854 msecs</td>
    </tr>
    <tr>
      <td><code>PureHeapSegment</code></td>
      <td>857 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, heap</td>
      <td>896 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, off-heap</td>
      <td>887 msecs</td>
    </tr>
  </tbody>
</table>

<h3 id="long-integer-accesses">Long integer accesses</h3>

<p><em>(note that the heap and off-heap segments use the same or comparable code for this)</em></p>

<p><strong>Writing 100000 x 4096 longs to 32768 bytes segment</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Segment</th>
      <th>Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>HeapMemorySegment</code>, mixed</td>
      <td>221 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, heap, mixed</td>
      <td>222 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, off-heap, mixed</td>
      <td>221 msecs</td>
    </tr>
    <tr>
      <td><code>PureHeapSegment</code></td>
      <td>194 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, heap</td>
      <td>220 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, off-heap</td>
      <td>221 msecs</td>
    </tr>
  </tbody>
</table>

<p><strong>Reading 100000 x 4096 longs from 32768 bytes segment</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Segment</th>
      <th>Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>HeapMemorySegment</code>, mixed</td>
      <td>233 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, heap, mixed</td>
      <td>232 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, off-heap, mixed</td>
      <td>231 msecs</td>
    </tr>
    <tr>
      <td><code>PureHeapSegment</code></td>
      <td>232 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, heap</td>
      <td>232 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, off-heap</td>
      <td>233 msecs</td>
    </tr>
  </tbody>
</table>

<p><strong>Writing 10 x 134217728 longs to 1073741824 bytes segment</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Segment</th>
      <th>Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>HeapMemorySegment</code>, mixed</td>
      <td>1,120 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, heap, mixed</td>
      <td>1,120 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, off-heap, mixed</td>
      <td>1,115 msecs</td>
    </tr>
    <tr>
      <td><code>PureHeapSegment</code></td>
      <td>1,148 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, heap</td>
      <td>1,116 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, off-heap</td>
      <td>1,113 msecs</td>
    </tr>
  </tbody>
</table>

<p><strong>Reading 10 x 134217728 longs from 1073741824 bytes segment</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Segment</th>
      <th>Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>HeapMemorySegment</code>, mixed</td>
      <td>1,097 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, heap, mixed</td>
      <td>1,099 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, off-heap, mixed</td>
      <td>1,093 msecs</td>
    </tr>
    <tr>
      <td><code>PureHeapSegment</code></td>
      <td>917 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, heap</td>
      <td>1,105 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, off-heap</td>
      <td>1,097 msecs</td>
    </tr>
  </tbody>
</table>

<h3 id="integer-accesses">Integer accesses</h3>

<p><em>(note that the heap and off-heap segments use the same or comparable code for this)</em></p>

<p><strong>Writing 100000 x 8192 ints to 32768 bytes segment</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Segment</th>
      <th>Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>HeapMemorySegment</code>, mixed</td>
      <td>578 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, heap, mixed</td>
      <td>580 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, off-heap, mixed</td>
      <td>576 msecs</td>
    </tr>
    <tr>
      <td><code>PureHeapSegment</code></td>
      <td>624 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, heap</td>
      <td>576 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, off-heap</td>
      <td>578 msecs</td>
    </tr>
  </tbody>
</table>

<p><strong>Reading 100000 x 8192 ints from 32768 bytes segment</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Segment</th>
      <th>Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>HeapMemorySegment</code>, mixed</td>
      <td>464 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, heap, mixed</td>
      <td>464 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, off-heap, mixed</td>
      <td>465 msecs</td>
    </tr>
    <tr>
      <td><code>PureHeapSegment</code></td>
      <td>463 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, heap</td>
      <td>464 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, off-heap</td>
      <td>463 msecs</td>
    </tr>
  </tbody>
</table>

<p><strong>Writing 10 x 268435456 ints to 1073741824 bytes segment</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Segment</th>
      <th>Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>HeapMemorySegment</code>, mixed</td>
      <td>2,187 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, heap, mixed</td>
      <td>2,161 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, off-heap, mixed</td>
      <td>2,152 msecs</td>
    </tr>
    <tr>
      <td><code>PureHeapSegment</code></td>
      <td>2,770 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, heap</td>
      <td>2,161 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, off-heap</td>
      <td>2,157 msecs</td>
    </tr>
  </tbody>
</table>

<p><strong>Reading 10 x 268435456 ints from 1073741824 bytes segment</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Segment</th>
      <th>Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>HeapMemorySegment</code>, mixed</td>
      <td>1,782 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, heap, mixed</td>
      <td>1,783 msecs</td>
    </tr>
    <tr>
      <td><code>HybridMemorySegment</code>, off-heap, mixed</td>
      <td>1,774 msecs</td>
    </tr>
    <tr>
      <td><code>PureHeapSegment</code></td>
      <td>1,501 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, heap</td>
      <td>1,774 msecs</td>
    </tr>
    <tr>
      <td><code>PureHybridSegment</code>, off-heap</td>
      <td>1,771 msecs</td>
    </tr>
  </tbody>
</table>
</div>


      </article>
    </div>

    <div class="row">
      <div id="disqus_thread"></div>
      <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'stratosphere-eu'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
             (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>
    </div>
  </div>
</div>
      </div>
    </div>

    <hr />

    <div class="row">
      <div class="footer text-center col-sm-12">
        <p>Copyright © 2014-2022 <a href="http://apache.org">The Apache Software Foundation</a>. All Rights Reserved.</p>
        <p>Apache Flink, Flink®, Apache®, the squirrel logo, and the Apache feather logo are either registered trademarks or trademarks of The Apache Software Foundation.</p>
        <p><a href="https://privacy.apache.org/policies/privacy-policy-public.html">Privacy Policy</a> &middot; <a href="/blog/feed.xml">RSS feed</a></p>
      </div>
    </div>
    </div><!-- /.container -->

    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="/js/jquery.matchHeight-min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/codetabs.js"></script>
    <script src="/js/stickysidebar.js"></script>
  </body>
</html>
